---
title: 常用系统工作命令命令
---




## 常用系统工作命令



### 关机命令

```bash
poweroff
# 关闭计算机操作系统并且切断系统电源

shutdown
# shutdown -h hours:minutes 定时关机
# shutdown -h +1  一分钟后关机
# shutdown +5 "System will shutdown after 5 minutes"  5分钟后关机，同时送出警告信息给登入用户

init 0
# init 进程是 Linux 内核引导运行的，是系统中的第一个进程。

halt -p
# halt 命令会先检测系统的 runlevel，若 runlevel 为 0 或 6，则关闭系统，否则即调用 shutdown 来关闭系统。
```



### 重启命令

```bash
reboot
# 和 windows 中的 restart 一样。注意：重启必须使用 root 权限

shutdown -r now
# 重启服务器
# shutdown -r +1 一分钟后重启

init 6
# 重启服务器
```



### 注销命令

```bash
logout
exit
ctrl + d
```


### 查看进程命令 - ps

ps 命令是 "process status" 的缩写，ps 命令用于显示当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。

```bash
# 显示所有进程并输出到ps.txt文件
ps -aux > ps.txt
ps -A > ps.txt

# 查找指定进程信息
ps -ef | grep ssh

# 显示指定用户信息
ps -u root

# 按 CPU 资源的使用量对进程进行排序：
ps aux | sort -rnk 3

# 按内存资源的使用量对进程进行排序：
ps aux | sort -rnk 3
```

![02-ps](C:\Users\Administrator\Pictures\Typora\02-ps.png)

| USER         | PID        | %CPU         | %MEM       | VSZ                         | RSS                           | TTY      | STAT     | START        | TIME                | COMMAND        |
| ------------ | ---------- | ------------ | ---------- | --------------------------- | ----------------------------- | -------- | -------- | ------------ | ------------------- | -------------- |
| 进程的所有者 | 进程 ID 号 | 运算器占用率 | 内存占用率 | 虚拟内存使用量（单位是 KB） | 占用的固定内存量（单位是 KB） | 所在终端 | 进程状态 | 被启动的时间 | 实际使用 CPU 的时间 | 命令名称与参数 |

**以下内容转载于：**[Linux 进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)](https://blog.csdn.net/shenwansangz/article/details/51981459)

> Linux 是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。
>
> - R（running，task_running 可执行状态）：只有在该状态的进程才可能在 CPU 上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的 task_struct 结构（进程控制块）被放入对应 CPU 的可执行队列中（一个进程最多只能出现在一个 CPU 的可执行队列中）。进程调度器的任务就是从各个 CPU 的可执行队列中分别选择一个进程在该 CPU 上运行。
>
>   很多操作系统教科书将正在 CPU 上执行的进程定义为 RUNNING 状态、而将可执行但是尚未被调度执行的进程定义为 READY 状态，这两种状态在 linux 下统一为 TASK_RUNNING 状态。
>
> - S（sleeping，task_interruptible 可中断的睡眠状态）：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起。这些进程的 task_struct 结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。
>
>   通过 ps 命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于 TASK_INTERRUPTIBLE 状态（除非机器的负载很高）。毕竟 CPU 就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU 又怎么响应得过来。
>
> - D（uninterruptible， task_uninterruptible 不可中断的睡眠状态）：与 task_interruptible 状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是 CPU 不响应外部硬件的中断，而是指进程不响应异步信号。
>   绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9 竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么 ps 命令看到的进程几乎不会出现 task_uninterruptible 状态，而总是 task_interruptible 状态。而 TASK_UNINTERRUPTIBLE 状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux 内核异步中断浅析》）
>   在进程对某些硬件进行操作时（比如进程调用 read 系统调用对某个设备文件进行读操作，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用 TASK_UNINTERRUPTIBLE 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的 TASK_UNINTERRUPTIBLE 状态总是非常短暂的，通过 ps 命令基本上不可能捕捉到。
>
>   linux 系统中也存在容易捕捉的 TASK_UNINTERRUPTIBLE 状态。执行 vfork 系统调用后，父进程将进入 TASK_UNINTERRUPTIBLE 状态，直到子进程调用 exit 或 exec（参见《神奇的 vfork》）。
>
>   通过下面的代码就能得到处于 TASK_UNINTERRUPTIBLE 状态的进程：
>
>   ```c
>   #include   void main() {  if (!vfork()) sleep(100);  }
>   ```
>
>   编译运行，然后 ps 一下：
>
>   ```bash
>   kouu@kouu-one:~/test$ ps -ax | grep a\.out  4371 pts/0    D+     0:00 ./a.out  4372 pts/0    S+     0:00 ./a.out  4374 pts/1    S+     0:00 grep a.out
>   ```
>
>   然后我们可以试验一下 TASK_UNINTERRUPTIBLE 状态的威力。不管 kill 还是 kill -9，这个 TASK_UNINTERRUPTIBLE 状态的父进程依然屹立不倒。
>
> - T（stopped，traced，task_stopped or task_traced 暂停状态或跟踪状态）：向进程发送一个 SIGSTOP 信号，它就会因响应该信号而进入 TASK_STOPPED 状态（除非该进程本身处于 TASK_UNINTERRUPTIBLE 状态而不响应信号）。（SIGSTOP 与 SIGKILL 信号一样，是非常强制的。不允许用户进程通过 signal 系列的系统调用重新设置对应的信号处理函数。）
>   向进程发送一个 SIGCONT 信号，可以让其从 TASK_STOPPED 状态恢复到 TASK_RUNNING 状态。
>
>   当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。"正在被跟踪"指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在 gdb 中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。
>
>   对于进程本身来说，TASK_STOPPED 和 TASK_TRACED 状态很类似，都是表示进程暂停下来。
>   而 TASK_TRACED 状态相当于在 TASK_STOPPED 之上多了一层保护，处于 TASK_TRACED 状态的进程不能响应 SIGCONT 信号而被唤醒。只能等到调试进程通过 ptrace 系统调用执行 PTRACE_CONT、PTRACE_DETACH 等操作（通过 ptrace 系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复 TASK_RUNNING 状态。
>
> - Z（zombie，task_dead - exit_zombie 僵尸状态）：退出状态，进程成为僵尸进程。进程在退出的过程中，处于 TASK_DEAD 状态。
>
>   在这个退出过程中，进程占有的所有资源将被回收，除了 task_struct 结构（以及少数资源）以外。于是进程就只剩下 task_struct 这么个空壳，故称为僵尸。
>   之所以保留 task_struct，是因为 task_struct 里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在 shell 中，\$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为 if 语句的判断条件。
>   当然，内核也可以将这些信息保存在别的地方，而将 task_struct 结构释放掉，以节省一些空间。但是使用 task_struct 结构更为方便，因为在内核中已经建立了从 pid 到 task_struct 查找关系，还有进程间的父子关系。释放掉 task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。
>
>   父进程可以通过 wait 系列的系统调用（如 wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。
>   子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来"收尸"。这个信号默认是 SIGCHLD，但是在通过 clone 系统调用创建子进程时，可以设置这个信号。
>
>   通过下面的代码能够制造一个 EXIT_ZOMBIE 状态的进程：
>
>   ```c
>   #include   void main() {  if (fork())  while(1) sleep(100);  }
>   ```
>
>   编译运行，然后 ps 一下：
>
>   ```bash
>   kouu@kouu-one:~/test$ ps -ax | grep a\.out  10410 pts/0    S+     0:00 ./a.out  10411 pts/0    Z+     0:00 [a.out]   10413 pts/1    S+     0:00 grep a.out
>   ```
>
>   只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程"收尸"？
>   当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是 1 号进程。所以每个进程、每时每刻都有父进程存在。除非它是 1 号进程。1 号进程，pid 为 1 的进程，又称 init 进程。
>   linux 系统启动后，第一个被创建的用户态进程就是 init 进程。它有两项使命：
>
>   1. 执行系统初始化脚本，创建一系列的进程（它们都是 init 进程的子孙）；
>
>   2. 在一个死循环中等待其子进程的退出事件，并调用 waitid 系统调用来完成"收尸"工作；
>      init 进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于 TASK_INTERRUPTIBLE 状态，"收尸"过程中则处于 TASK_RUNNING 状态。
>
> - X（task_dead - exit_dead 退出状态）：进程即将被销毁。而进程在退出过程中也可能不会保留它的 task_struct。比如这个进程是多线程程序中被 detach 过的进程（进程？线程？参见《linux 线程浅析》）。
>
>   或者父进程通过设置 SIGCHLD 信号的 handler 为 SIG_IGN，显式的忽略了 SIGCHLD 信号。（这是 posix 的规定，尽管子进程的退出信号可以被设置为 SIGCHLD 以外的其他信号。）
>   此时，进程将被置于 EXIT_DEAD 退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以 EXIT_DEAD 状态是非常短暂的，几乎不可能通过 ps 命令捕捉到。


### 查看进程命令 - pgrep

pgrep 命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程 id。每一个进程 ID 以一个十进制数表示，通过一个分割字符串和下一个 ID 分开，默认的分割字符串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分割的可能值的集合。

pgrep 命令就是检索正在运行的进程，显示匹配准则是进程的 PID，可跟正则表达式来匹配进程或命令行。选择进程拥有者时，默认匹配规则是逻辑与的关系。

**语法格式：**pgrep [参数][模式]

**常用参数：**

| 参数 | 功能                                      |
| ---- | ----------------------------------------- |
| -d   | 设置一个字符串，用于分隔输出的每个进程 ID |
| -f   | 模式参数仅用于匹配进程名                  |
| -I   | 列出进程名及进程 ID                       |
| -P   | 仅选择匹配指定父进程 ID 的进程            |
| -u   | 选择仅匹配指定有效用户 ID 进程            |
| -U   | 选择仅匹配指定真实用户 ID 的进程          |

**模式：**

进程名称：指定要查找的进程名称，同时也支持类似 grep 指令中的匹配模式。

![07-pgrep]()



### 查看系统运行状态 - top

top 命令用于动态地监视进程活动与系统负载等信息，查看系统实时运维状态，可以将其看作 Linux 中的"强化版的 Windows 任务管理器"。

![02-top](C:\Users\Administrator\Pictures\Typora\02-top.png)

在图中，top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。

**第一行**，任务队列信息，同 uptime 命令的执行结果

- 系统时间：06:20:15
- 运行时间：up 0:16 min,
- 当前登录用户： 2 user
- 负载均衡(uptime) load average: 0.22, 0.09, 0.07。 average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况，数值越小意味着负载越低。load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了

**第二行**，Tasks — 任务（进程）

- 总进程:494 total, 运行:1 running, 休眠:493sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie

**第三行**，cpu 状态信息

- 1.8%us【user space】— 用户空间占用 CPU 的百分比。
- 0.5%sy【sysctl】— 内核空间占用 CPU 的百分比。
- 0.0%ni【nice】— 改变过优先级的进程占用 CPU 的百分比
- 97.7%id【idolt】— 空闲 CPU 百分比
- 0.0%wa【wait】— IO 等待占用 CPU 的百分比
- 0.0%hi【Hardware IRQ】— 硬中断占用 CPU 的百分比
- 0.0%si【Software Interrupts】— 软中断占用 CPU 的百分比

**第四行**，内存状态

- 物理内存总量 2035648 total,
- 内存使用量 1304176 used,
- 内存空闲量 731472 free,
- 作为内核缓冲的内存量 928 buffers

**第五行**，swap 交换分区信息

- 虚拟内存总量 2097148 total,
- 虚拟内存使用总量 0 used,
- 虚拟内存空闲量 2097148 free.
- 已被提前加载的内存量 455132 cached Mem

| PID        | USER         | PR         | NI                                          | VIRT                   | RES                                | SHR          | S        | %CPU       | %MEM       | TIME+               | COMMAND        |
| ---------- | ------------ | ---------- | ------------------------------------------- | ---------------------- | ---------------------------------- | ------------ | -------- | ---------- | ---------- | ------------------- | -------------- |
| 进程 ID 号 | 进程的所有者 | 进程优先级 | nice 值。负值表示高优先级，正值表示低优先级 | 进程使用的虚拟内存总量 | 进程使用的、未被换出的物理内存大小 | 共享内存大小 | 进程状态 | CPU 占用率 | 内存占用率 | 实际使用 CPU 的时间 | 命令名称与参数 |

VIRT：virtual memory usage 虚拟内存 VIRT=SWAP+RES

进程"需要的"虚拟内存大小，包括进程使用的库、代码、数据等

- 假如进程申请 100m 的内存，但实际只使用了 10m，那么它会增长 100m，而不是实际的使用量

RES：resident memory usage 常驻内存 RES=CODE+DATA

- 进程当前使用的内存大小，但不包括 swap out
- 包含其他进程的共享
- 如果申请 100m 的内存，实际使用 10m，它只增长 10m，与 VIRT 相反
- 关于库占用内存的情况，它只统计加载的库文件所占内存大小

SHR：shared memory 共享内存

- 除了自身进程的共享内存，也包括其他进程的共享内存
- 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
- 计算某个进程所占的物理内存大小公式：RES – SHR
- swap out 后，它将会降下来

DATA

- 数据占用的内存。如果 top 没有显示，按 f 键可以显示出来。
- 真正的该程序要求的数据空间，是真正在运行中要使用的。

**语法格式：**top [参数]

**常用参数：**

| 选项 | 功能                                                                                   |
| ---- | -------------------------------------------------------------------------------------- |
| -d   | 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s                       |
| -q   | 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行 |
| -c   | 切换显示模式                                                                           |
| -s   | 安全模式，将交谈式指令取消, 避免潜在的危机                                             |
| -i   | 不显示任何闲置 (idle) 或无用 (zombie) 的行程                                           |
| -n   | 更新的次数，完成后将会退出 top                                                         |
| -b   | 批次档模式，搭配 "n" 参数一起使用，可以用来将 top 的结果输出到档案内                   |



### 查询程序的进程 ID - pidof

pidof 命令用于检索指定的命令，返回相应的进程 ID。其中 program 是一个或多个命令或进程的名字。当需要终止某个进程时，传统的做法是利用 ps 命令列出所有的进程，使用 grep 命令选出目标进程，然后使用 kill 命令终止进程。

利用 pidof 命令，可以省略 ps 与 grep 组合命令，直接把指定命令的进程 ID 写入到标准输出。

**语法格式：**pidof [参数]

**常用参数：**

| 参数 | 功能                                          |
| ---- | --------------------------------------------- |
| -s   | 当系统中存在多个同名进程时，仅返回一个进程 ID |
| -c   | 仅返回当前正在运行且具有同一根目录的进程 PID  |
| -x   | 返回指定运行脚本的 shell 进程 PID             |
| -o   | 忽略具有指定进程 ID 的进程                    |

![02-pidof](C:\Users\Administrator\Pictures\Typora\02-pidof.png)



### 终止指定服务进程 - kill

kill 正如这个单词的意思一样，就是杀死。linux 系统中 kill 命令用来删除执行中的程序或工作。

kill 命令可将指定的信号发送给相应的进程或工作。 kill 命令默认使用信号为 SIGTERM(15)，用于结束进程或工作。如果进程或工作忽略此信号，则可以使用信号 9，强制杀死进程或作业。

**语法格式：**kill [参数][进程号]

**常用参数：**

| 参数 | 功能                                                   |
| ---- | ------------------------------------------------------ |
| -l   | 列出系统支持的信号                                     |
| -s   | 指定向进程发送的信号                                   |
| -a   | 处理当前进程时不限制命令名和进程号的对应关系           |
| -p   | 指定 kill 命令只打印相关进程的进程号，而不发送任何信号 |
| -u   | 指定用户                                               |

只有第 9 种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。常用信号：

- HUP 1 终端断线
- INT 2 中断（同 Ctrl + C）
- QUIT 3 退出（同 Ctrl + \）
- TERM 15 终止
- KILL 9 强制终止
- CONT 18 继续（与 STOP 相反， fg/bg 命令）
- STOP 19 暂停（同 Ctrl + Z）

![02-kill](C:\Users\Administrator\Pictures\Typora\02-kill.png)



### 终止指定服务全部进程 - killall

killall 命令用于终止某个指定名称的服务所对应的全部进程。

通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。

**语法格式**：killall [参数]

**常用参数**：

| 参数 | 功能                                   |
| ---- | -------------------------------------- |
| -e   | 对长名称进行精确匹配                   |
| -l   | 打印所有已知信号列表                   |
| -p   | 杀死进程所属的进程组                   |
| -i   | 交互式杀死进程，杀死进程前需要进行确认 |
| -r   | 使用正规表达式匹配要杀死的进程名称     |
| -s   | 用指定的进程号代替默认信号"SIGTERM"    |
| -u   | 杀死指定用户的进程                     |

![02-killall](C:\Users\Administrator\Pictures\Typora\02-killall.png)

> 如果我们在系统终端中执行一个命令后想立即停止它，可以同时按下 Ctrl + C 组合键（生产环境中比较常用的一个快捷键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加上一个&符号，这样命令将进入系统后台来执行。


### 给指定进程发送信号 - skill

skill 命令送个讯号给正在执行的程序，预设的讯息为 TERM (中断)，较常使用的讯息为 HUP、INT、KILL、STOP、CONT 和 0。

讯息有三种写法：分别为 -9、-SIGKILL、-KILL，可以使用 -l 或 -L 已列出可使用的讯息。

**语法格式：**skill [讯号名称][选择程序的规则]

**常用参数：**

| 参数 | 功能                           |
| ---- | ------------------------------ |
| -v   | 详细输出/ 列出所选择程序的资讯 |
| -n   | 没有动作/ 显示程序代号         |
| -t   | 终端机代号                     |
| -u   | 使用者名称                     |
| -w   | 智能警告讯息/ 尚未完成         |

此命令用途很广。如果您要停止 "oracle" 用户的所有进程，只需要一个命令即可实现：

```
skill -STOP oracle
```

可以使用用户、PID、命令或终端 id 作为参数。以下命令可停止所有 rman 命令。

```
skill -STOP rman
```

如您所见，skill 决定您输入的参数（进程 ID、用户 ID 或命令）并进行相应操作。这可能会导致在某些情况下出现这样的问题：您可能具有同名的用户和命令。最好的示例是 "oracle" 进程，通常由用户 "oracle" 运行。因此，当您希望停止名为 "oracle" 的进程时，可执行以下命令：

```
skill -STOP oracle
```

用户 "oracle" 的所有进程都停止，包括您可能要使用的会话。要非常明确地执行命令，您可以选择使用一个新参数指定参数的类型。要停止一个名为 oracle 的命令，可执行以下命令：

```
skill -STOP -c oracle
```

![07-skill]()


### 按照进程名杀死进程 - pkill

pkill 命令可以按照进程名杀死进程。pkill 和 killall 应用方法差不多，也是直接杀死运行中的程序。如果想杀掉单个进程，请用 kill 来杀掉。**kill 对应的是 PID，pkill 对应的是 command。**

**语法格式：**pkill [参数]

**常用参数：**

| 参数 | 功能                                 |
| ---- | ------------------------------------ |
| -o   | 仅向找到的最小（起始）进程号发送信号 |
| -n   | 仅向找到的最大（结束）进程号发送信号 |
| -P   | 指定父进程号发送信号                 |
| -g   | 指定进程组                           |
| -t   | 指定开启进程的终端                   |

![07-pkill]()


### 控制系统服务 - service

service 命令是 Redhat Linux 兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。

**语法格式**：service [参数]

**常用参数**：

| 参数         | 功能             |
| ------------ | ---------------- |
| --status-all | 显示所服务的状态 |
| -h           | 显示帮助信息     |

- 服务名：自动要控制的服务名，即`/etc/init.d`目录下的脚本文件名；
- 控制命令：系统服务脚本支持的控制命令。

![07-service]()


### 检查与设置系统的各种服务 - chkconfig

chkconfig 命令检查、设置系统的各种服务。这是 Red Hat 公司遵循 GPL 规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。谨记 chkconfig 不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。

**语法格式：**chkconfig [参数]

**常用参数：**

| 参数    | 功能                                                                                        |
| ------- | ------------------------------------------------------------------------------------------- |
| --add   | 增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据 |
| --del   | 删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据   |
| --level | 指定读系统服务要在哪一个执行等级中开启或关毕                                                |

> 等级代号列表：
>
> - 等级 0 表示：表示关机
> - 等级 1 表示：单用户模式
> - 等级 2 表示：无网络连接的多用户命令行模式
> - 等级 3 表示：有网络连接的多用户命令行模式
> - 等级 4 表示：不可用
> - 等级 5 表示：带图形界面的多用户模式
> - 等级 6 表示：重新启动
>
> 需要说明的是，level 选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init 不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。
>
> 运行级文件：
>
> 每个被 chkconfig 管理的服务需要在对应的 init.d 下的脚本加上两行或者更多行的注释。第一行告诉 chkconfig 缺省启动的运行级以及启动和停止的优先级。如果某服务缺省不在任何运行级启动，那么使用`-`代替运行级。第二行对服务进行描述，可以用`\`跨行注释。

如何增加一个服务：

1. 服务脚本必须存放在`/etc/ini.d/`目录下；
2. `chkconfig --add servicename`在 chkconfig 工具服务列表中增加此服务，此时服务会被在`/etc/rc.d/rcN.d`中赋予 K/S 入口了；
3. `chkconfig --level 35 mysqld on`修改服务的默认启动等级。

![07-chkconfig]()


### 管理系统服务 - systemctl

systemctl 命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。

RHEL7 之后从 init 完全换成了 systemd 的启动方式，systemd 启动服务的机制主要是通过 systemctl 的这个系统服务管理指令来处理。systemctl 在用法上也囊括 `service` / `chkconfig` / `setup` / `init` 的大部分功能。

**语法格式**：systemctl [参数][服务]

**常用参数：**

| -start                      | 启动服务           |
| --------------------------- | ------------------ |
| -stop                       | 停止服务           |
| -restart                    | 重启服务           |
| -enable                     | 使某服务开机自启   |
| -disable                    | 关闭某服务开机自启 |
| -status                     | 查看服务状态       |
| -list -units --type=service | 列举所有已启动服务 |

| 任务                 | 旧指令                        | 新指令                                                                                                 |
| -------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------ |
| 使某服务自动启动     | chkconfig --level 3 httpd on  | systemctl enable httpd.service                                                                         |
| 使某服务不自动启动   | chkconfig --level 3 httpd off | systemctl disable httpd.service                                                                        |
| 检查服务状态         | service httpd status          | systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active) |
| 显示所有已启动的服务 | chkconfig --list              | systemctl list-units --type=service                                                                    |
| 启动某服务           | service httpd start           | systemctl start httpd.service                                                                          |
| 停止某服务           | service httpd stop            | systemctl stop httpd.service                                                                           |
| 重启某服务           | service httpd restart         | systemctl restart httpd.service                                                                        |

![07-systemctl]()


### 显示已登录用户 - w

w 命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行 w 命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。

**语法格式：**w [参数]

**常用参数：**

| 参数            | 功能                                  |
| --------------- | ------------------------------------- |
| -h/--no-header  | 不打印头信息                          |
| -u/--no-current | 当显示当前进程和 cpu 时间时忽略用户名 |
| -s/--short      | 使用短输出格式                        |
| -f/--from       | 显示用户从哪登录                      |
| -o/--old-style  | 老式输出                              |
| -i/--ip-addr    | 显示 IP 地址而不是主机名（如果可能）  |
| --help          | 显示此帮助并退出                      |
| -V/--version    | 显示版本信息                          |

![07-w]()


### 显示进程之间的派生关系 - pstree

**pstree 命令**以树状图的方式展现进程之间的派生关系，显示效果比较直观。


#### 语法

```bash
pstree(选项)
```


#### 选项

```bash
-a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示；
-c：不使用精简标示法；
-G：使用VT100终端机的列绘图字符；
-h：列出树状图时，特别标明现在执行的程序；
-H<程序识别码>：此参数的效果和指定"-h"参数类似，但特别标明指定的程序；
-l：采用长列格式显示树状图；
-n：用程序识别码排序。预设是以程序名称来排序；
-p：显示程序识别码；
-u：显示用户名称；
-U：使用UTF-8列绘图字符；
-V：显示版本信息。
```

![07-pstree]()


## 参考

- [Linux 进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)](https://blog.csdn.net/shenwansangz/article/details/51981459)
- [Linux top 命令详解](https://www.cnblogs.com/niuben/p/12017242.html)
